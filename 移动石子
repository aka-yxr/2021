一共有 n 个箱子排成一排，从左到右依次编号为 1∼n。

其中，第 i 号箱子中放有 ai 个石子。

现在，你可以进行最多 d 次操作。

每次操作可以将一个石子从一个箱子移动至另一个与其相邻的箱子里。

我们希望通过合理操作使得 1 号箱子内的石子数量尽可能大。

请问，这个最大可能值是多少？

输入格式
第一行包含整数 T，表示共有 T 组测试数据。

每组数据第一行包含两个整数 n 和 d。

第二行包含 n 个整数 a1,a2,…,an。

输出格式
每组数据输出一行结果，表示答案。

数据范围
1≤T≤100,
1≤n,d≤100,
0≤ai≤100
输入样例：
3
4 5
1 0 3 2
2 2
100 1
1 8
0
输出样例：
3
101
0

-------------------------------------------------------------------------
AC
题目理解：在一排（n）个箱子中(每个箱子中有ai个石头)，在有限次（d次）操作中，把石头移到最前面的箱子中
遍历到一个箱子，如果箱子中的石头个数与需挪动次数的乘积 小于等于 当前剩余操作次数  则将该箱子中全部石子加到结果石子数量 retret 中；
否则，用当前剩余操作次数除以当前箱子每个石子需挪动次数得到最多可以挪动的石子数量，将其加入 retret

-------------------------------------------------------------------------
#include<stdio.h>

int main()
{
    int T;
    int n;
    int d;
    int a[101] = {0};
    
    scanf("%d",&T);
    while(T--)
    {
        scanf("%d %d",&n,&d);
        for(int i = 0; i < n; i++)
        {
            scanf("%d",&a[i]);
        }
        int ret= 0;
        for(int i = 0;i < n; i++)
        {
            if(d < a[i] * i) 
            {
                ret += d / i;
                break;
            } 
            else 
            {
                ret += a[i];
                d -= a[i] * i;
            }
        }
        printf("%d\n",ret);
    }
    
    return 0;
}
-------------------------------------------------------------------------
