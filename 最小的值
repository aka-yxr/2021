给定两个长度为 n 的 01 数组 a1,a2,…,an 和 b1,b2,…,bn。

请你构造一个长度为 n 的正整数数组 p1,p2,…,pn。

要求 ∑i=1nai×pi>∑i=1nbi×pi 成立。

此外，maxi=1npi 需要尽可能小。

输出最小可能值。

输入格式
第一行包含整数 n。

第二行包含 n 个整数 a1,a2,…,an。

第三行包含 n 个整数 b1,b2,…,bn。

输出格式
输出 maxi=1npi 的最小可能值。

如果不存在满足条件的数组 p，则输出 −1。

数据范围
1≤n≤100,
0≤ai,bi≤1
输入样例1：
5
1 1 1 0 0
0 1 1 1 1
输出样例1：
3
输入样例2：
3
0 0 0
0 0 0
输出样例2：
-1
输入样例3：
4
1 1 1 1
1 1 1 1
输出样例3：
-1
输入样例4：
9
1 0 0 0 0 0 0 0 1
0 1 1 0 1 1 1 1 0
输出样例4：
4

--------------------------------------------------------------
AC
统计a打败b和b打败a的次数，a比b多结果就为1，没有一次打败为-1，如果少于就把差值平均到打赢的次数上就行。
--------------------------------------------------------------
#include<stdio.h>

int main(){
    int n;
    scanf("%d",&n);
    int a[n+1],b[n+1];
    
    for (int i=1;i<=n;++i) scanf("%d",&a[i]);
    for (int i=1;i<=n;++i) scanf("%d",&b[i]);
    int cnt1=0,cnt2=0;

    for (int i=1;i<=n;++i){
        if (a[i]==1 && b[i]!=1) cnt1++;
        if (a[i]==0 && b[i]!=0) cnt2++;
    }
    if (cnt1 ==0) printf("-1\n");
    else if(cnt1>cnt2) printf("1\n");
    else printf("%d\n",((cnt2-cnt1)/cnt1)+2);

}
--------------------------------------------------------------
